use mmtk::vm::Scanning;
use mmtk::{TransitiveClosure, Mutator};
use mmtk::util::{Address, ObjectReference, VMWorkerThread};
use mmtk::scheduler::{ProcessEdgesWork};
use mmtk::scheduler::GCWorker;
use std::os::raw::{c_void, c_ulong};
use crate::Ruby;

/* automatically generated by rust-bindgen 0.57.0 */
#[allow(non_camel_case_types)]
pub type size_t = c_ulong;

// Passed to C to perform the transitive closure
pub unsafe extern "C" fn call_process_edge<T: TransitiveClosure>(closure: &mut T, adjacent: *mut *mut c_void) {
    closure.process_edge(Address::from_ptr(adjacent));
}

pub struct VMScanning {}

impl Scanning<Ruby> for VMScanning {
    fn scan_objects<W: ProcessEdgesWork<VM=Ruby>>(_objects: &[ObjectReference], _worker: &mut GCWorker<Ruby>) {
        unimplemented!()
    }

    fn scan_thread_roots<W: ProcessEdgesWork<VM=Ruby>>() {
        unimplemented!()
    }

    fn scan_thread_root<W: ProcessEdgesWork<VM=Ruby>>(_mutator: &'static mut Mutator<Ruby>, _tls: VMWorkerThread) {
        unimplemented!()
    }

    fn scan_vm_specific_roots<W: ProcessEdgesWork<VM=Ruby>>() {
        unimplemented!()
    }

    fn scan_object<T: TransitiveClosure>(_trace: &mut T, _object: ObjectReference, _tls: VMWorkerThread) {
        unimplemented!()
    }

    fn notify_initial_thread_scan_complete(_partial_scan: bool, _tls: VMWorkerThread) {
        unimplemented!()
    }

    fn supports_return_barrier() -> bool {
        false
    }

    fn prepare_for_roots_re_scanning() {
        todo!()
    }
}
