use mmtk::vm::{Scanning, GCThreadContext};
use mmtk::{TransitiveClosure, Mutator, MutatorContext, memory_manager};
use mmtk::util::{Address, ObjectReference, VMWorkerThread};
use mmtk::scheduler::{ProcessEdgesWork, GCWork, WorkBucketStage};
use mmtk::scheduler::GCWorker;
use std::os::raw::{c_void, c_ulong};
use crate::abi::{GCThreadTLS, BufferCallback};
use crate::address_buffer::FilledBuffer;
use crate::gc_work::ObjectsToObjectsWork;
use crate::{Ruby, upcalls, SINGLETON};

/* automatically generated by rust-bindgen 0.57.0 */
#[allow(non_camel_case_types)]
pub type size_t = c_ulong;

// Passed to C to perform the transitive closure
pub unsafe extern "C" fn call_process_edge<T: TransitiveClosure>(closure: &mut T, adjacent: *mut *mut c_void) {
    closure.process_edge(Address::from_ptr(adjacent));
}

pub struct VMScanning {}

impl Scanning<Ruby> for VMScanning {
    const SINGLE_THREAD_MUTATOR_SCANNING: bool = false;

    fn scan_objects<W: ProcessEdgesWork<VM=Ruby>>(_objects: &[ObjectReference], _worker: &mut GCWorker<Ruby>) {
        panic!("This should not be called.  We scan objects by directly calling into Ruby");
    }

    fn scan_thread_roots<W: ProcessEdgesWork<VM=Ruby>>() {
        (upcalls().scan_thread_roots)()
    }

    fn scan_thread_root<W: ProcessEdgesWork<VM=Ruby>>(mutator: &'static mut Mutator<Ruby>, tls: VMWorkerThread) {
        let gc_tls = GCThreadTLS::from_vwt_check(tls);
        let callback = |_, filled_buffer: FilledBuffer| {
            debug!("[scan_thread_root] Buffer delivered.");
            let bucket = WorkBucketStage::Closure;
            let packet = ObjectsToObjectsWork::<W>::new(filled_buffer.as_objref_vec());
            memory_manager::add_work_packet(&SINGLETON, bucket, packet);
        };
        gc_tls.run_with_buffer_callback(callback, |gc_tls| {
            (upcalls().scan_thread_root)(mutator.get_tls(), tls);
        });
    }

    fn scan_vm_specific_roots<W: ProcessEdgesWork<VM=Ruby>>() {
        let gc_tls = GCThreadTLS::from_upcall_check();
        let callback = |_, filled_buffer: FilledBuffer| {
            debug!("[scan_vm_specific_roots] Buffer delivered.");
            let bucket = WorkBucketStage::Closure;
            let packet = ObjectsToObjectsWork::<W>::new(filled_buffer.as_objref_vec());
            memory_manager::add_work_packet(&SINGLETON, bucket, packet);
        };
        gc_tls.run_with_buffer_callback(callback, |gc_tls| {
            (upcalls().scan_vm_specific_roots)();
        });
    }

    fn scan_object<T: TransitiveClosure>(_trace: &mut T, _object: ObjectReference, _tls: VMWorkerThread) {
        panic!("This should not be called.  We scan objects by directly calling into Ruby");
    }

    fn notify_initial_thread_scan_complete(_partial_scan: bool, _tls: VMWorkerThread) {
        // Do nothing
    }

    fn supports_return_barrier() -> bool {
        false
    }

    fn prepare_for_roots_re_scanning() {
        todo!()
    }
}
